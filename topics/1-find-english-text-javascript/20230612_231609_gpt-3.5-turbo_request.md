# USER:
I want this script to prompt the user with German language.
Find all relevant texts.

As a positive example consider:
$email.after(`<label id="email-error" class="error" for="email">Please enter a valid email address</label>`); .

This is one of the instructions that I want you to extract.

Please exclude all logging statements. For example:
logThisState("inlineCP:submitHandler: startCheckout");
this is a negative example because this is only for logging and logging is OK to be in English.

Now please extract all instructions that could show the user english text.

# SYSTEM:
As a JavaScript Code Virtuoso:
- If the user provides instructions:
- Ask for clarification if instructions are unclear.
- Otherwise, write JavaScript code following user instructions.
- Preserve or improve any comments in the code.
- Follow JavaScript's best practices and coding standards.
- Provide explanations of the code if the user asks.
- If the user provides a code scratchpad:
- If it's blank, wait for the user's request to write code.
- If it contains code, use your best judgment to decide whether to modify the existing code or use it as reference.

Coding scratchpad:
```typescript

/**
 * Check if there is valid subscription
 * - if there is and it's digital, then show and exit
 * - if there is not then call the handler function which can be:
 *      -  await purchaseSubscription();
 *      or it is
 *      -  await checkExistingPayment();
 *
 * @param {string} email
 * @param {function} callback  is called if there is no valid subscription
 */
export async function checkExistingSubs(email: string, callback: () => Promise<void>) {
    try {

        logThisState("checkExistingSubs: for email", email);
        const resSubsInfo = await subscriptionAPIs.getExistingSubsInfo(email);
        logThisState("checkExistingSubs: got existingSubsInfo", resSubsInfo);
        let hasExistingSubscription = resSubsInfo && resSubsInfo.data && resSubsInfo.data.product_id;
        if (hasExistingSubscription) {
            cpState.customerData.customer_id = resSubsInfo.data.customer_id;
            logThisState("checkExistingSubs: found customer_id", cpState.customerData.customer_id);
        }
        if (cpState.customerData.forced_invalid_subscription) {
            hasExistingSubscription = false;
        }

        if (!hasExistingSubscription) {
            if (typeof callback == 'function') {
                logThisState("checkExistingSubs: has no valid Data Subscription, or simulated:", cpState.customerData.forced_invalid_subscription);
                callback();
            }
            return;
        }
        const subs_type = resSubsInfo.data.product_id;
        logThisState("checkExistingSubs: has existingSubInfo with subscription_type", subs_type);
        const subs_status = ('' + resSubsInfo.data.subscription_status).toLowerCase();

        if (digital_prod_id.includes(cpState.offerDetail.offer_detail.plan.product.id)) {
            if (subs_status === "active"
                && (digital_prod_id.includes(subs_type))) {
                logThisState("checkExistingSubs: has active existingSubInfo call handleExistingSubscription");
                handleExistingSubscription(subs_type);
                return;
            }


            if (typeof callback == 'function') {
                callback();
            }
        } else {
            if (typeof callback == 'function') {
                callback();
            }
        }
    } catch (e) {
        console.error("checkExistingSubs: e=", e);
        if (typeof callback == 'function') {
            callback();
        }
        ga('send', 'event', 'Digital Checkout Page', 'ERROR check existing subs info', JSON.stringify(e));
    }
}

export async function checkExistingPayment() {
    if (cpState.customerData.forced_invalid_payment) {
        logThisState("checkExistingPayment: forced to set payment to invalid");
        return;
    }
    if (!cpState.customerData.customer_id) {
        logThisState("checkExistingPayment: does not have an existing customer_id");
        return;
    }
    try {
        logThisState("checkExistingPayment: for cpState.customerData.customer_id", cpState.customerData.customer_id);
        let resPaymentMethod = await subscriptionAPIs.getPaymentMethod();
        logThisState("checkExistingPayment: got payment method", resPaymentMethod);
        if (resPaymentMethod && resPaymentMethod.data && !$.isEmptyObject(resPaymentMethod.data)) {
            logThisState("checkExistingPayment: payment method is set, calling handleExistingPayment " +
                "for resPaymentMethod.data.MaskedNumber", resPaymentMethod.data.MaskedNumber);
            handleExistingPayment(resPaymentMethod.data.MaskedNumber);
            cpState.hasExistingPayment = true;
            logThisState("checkExistingPayment: cpState.hasExistingPayment is set");
            cpState.customerData.customer_id = resPaymentMethod.data.CustomerID;
            logThisState("checkExistingPayment: set customer ID cpState.customerData.customer_id", cpState.customerData.customer_id);
        }
    } catch (error) {
        logThisState("checkExistingPayment: got error", error);
        ga('send', 'event', 'Digital Checkout Page', 'ERROR check existing payment information', JSON.stringify(error));
    }
}

//
```

