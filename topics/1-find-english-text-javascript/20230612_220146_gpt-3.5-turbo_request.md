# USER:
I want this script to prompt the user with German language.
Find all relevant texts.

As a positive example consider:
$email.after(`<label id="email-error" class="error" for="email">Please enter a valid email address</label>`); .

This is one of the instructions that I want you to extract.

As a negative example consider:
logThisState("inlineCP:submitHandler: startCheckout");
this is a negative example because this is only for logging and logging is OK to be in English.

Now please extract all instructions that could show the user english text.

# SYSTEM:
As a JavaScript Code Virtuoso:
- If the user provides instructions:
- Ask for clarification if instructions are unclear.
- Otherwise, write JavaScript code following user instructions.
- Preserve or improve any comments in the code.
- Follow JavaScript's best practices and coding standards.
- Provide explanations of the code if the user asks.
- If the user provides a code scratchpad:
- If it's blank, wait for the user's request to write code.
- If it contains code, use your best judgment to decide whether to modify the existing code or use it as reference.

Coding scratchpad:
function registerSEPA_creditCardChange() {

    $('#lastschrift-tab, #credit-card-tab, #paypal-tab').on('shown.bs.tab',
        async function (event: JQuery.TriggeredEvent) {
            const activeTabId = (event.target as HTMLElement).id;

            logThisState("registerSEPA_creditCardChange: activeTabId", activeTabId);

            if (activeTabId === 'lastschrift-tab') {
                await initializeStripePaymentForSepa();
            } else if (activeTabId === 'credit-card-tab') {
                await initializeStripePaymentForCreditCard();
            } else if (activeTabId === 'paypal-tab') {
                cpState.paymentType = 'paypal';
            }
        });
}
export async function initializeCheckoutPage(params: any = {}) {
    logThisState("window.initInlineCP: window.epCheckoutParams is called", window.epCheckoutParams);

    let $email = $('#email');
    if (params?.autofocus) {
        $email.trigger('focus');
    }
    await setCpPageState();
    logThisState("checkout-inline-digital called cpState=", cpState);

    if (cpState.afterTrialPlan.planId) {
        window.nextPlanDescription = {
            planId: cpState.afterTrialPlan.planId,
            planPeriod: cpState.afterTrialPlan.planPeriod,
            planPeriodUnit: cpState.afterTrialPlan.planPeriodUnit,
            valueCharge: cpState.afterTrialPlan.planPrice
        }
    } else {
        window.nextPlanDescription = {
            planId: cpState.selectedPlanDescription.planId,
            planPeriod: cpState.selectedPlanDescription.planPeriod,
            planPeriodUnit: cpState.selectedPlanDescription.planPeriodUnit,
            valueCharge: cpState.selectedPlanDescription.planPrice
        }
    }
    logThisState("window.initInlineCP: window.epCheckoutParams", window.epCheckoutParams);
    logThisState("window.initInlineCP: window.epSubs", window.epSubs);

    const allUrlParams = window.epSubs.getAllUrlParams();
    logThisState("window.initInlineCP: allUrlParams (note: compare with window.extractedURLParams)", allUrlParams);

    handleCustomFields();

    registerSEPA_creditCardChange();


    let stripePaymentSelected = true;
    if (stripePaymentSelected) {
        logThisState("window.initInlineCP: isStripePaymentSelected: true with cpState", cpState)
        $('#payment-stripe').show();
        await initializeStripePaymentForSepa();
    } else {
        logThisState("window.initInlineCP: isStripePaymentSelected: false with cpState", cpState)
    }

    if (cpState.isLoggedIn) {
        cpState.customerData.token = allUrlParams.token ? allUrlParams.token : getCookie("epoch_token");
        cpState.customerData.userid = ($ as any).cookie("epoch_user_id");

        await setCustomerDetails();
    } else if (window.epCheckoutParams.email) {
        let email = decodeURIComponent(window.epCheckoutParams.email);
        $email.val(email);
        $email.attr('disabled', 'true');

        if (window.epCheckoutParams.firstname) {
            let firstname = decodeURIComponent(window.epCheckoutParams.firstname);
            $('#customer-fname').val(firstname);
            if (window.epCheckoutParams.lastname) {
                let lastname = decodeURIComponent(window.extractedURLParams.lastname);
                $('#customer-lname').val(lastname);
            }
        }
    }

    try {
        $('#zip').mask('0000');
    } catch (e) {
        console.warn("Error setting zip mask: ", e);
    }

    let $input = $("input");
    $input.on("focus", function () {
        $(this).addClass("focus");
    });
    $input.on("blur", function () {
        $(this).removeClass("focus");
    });

    $input.on("keyup", function () {
        if ($(this).val()) {
            $(this).removeClass("empty");
            $(this).addClass("val");
        } else {
            $(this).addClass("empty");
            $(this).removeClass("val");
        }
    });

    initializeFormValidationAndSubmitHandler();

    showPlanDescription();
    try {
        let planData = cpState.selectedPlanDescription.planId;
        planData += (window.epCheckoutParams.cf_plan_after_trial_ends) ? "---" + window.epCheckoutParams.cf_plan_after_trial_ends : "";
        const dataForTracking = {
            "abtest_id": ($ as any).cookie('digital_subscription_tracking_abtest_id') || "",
            "user_id": ($ as any).cookie('epoch_user_id'),
            "category": 'Checkout ' + cpState.selectedPlanDescription.planType + ' Page Loaded',
            "action": planData,
            "label": window.epCheckoutParams.src_cat,
            "src_cat": window.epCheckoutParams.src_cat,
            "src_tmp": window.epCheckoutParams.src_tmp,
            "src_url": window.epCheckoutParams.src_url,
            "src_cmp": window.epCheckoutParams.src_cmp,
            "value": '',
            "metadata": window.checkoutEngineVersion,
            "page": window.location.href,
            "canonical_url": window.epCheckoutParams.src_url,
            "real_url": window.epCheckoutParams.src_url,
            "json_data": JSON.stringify({
                params: window.epCheckoutParams,
                checkoutEngineVersion: window.checkoutEngineVersion
            })
        };
        logThisState("window.initInlineCP: db/senddata: dataForTracking", dataForTracking);
        window.epSubs.trackDataEvent(dataForTracking);
    } catch (e) {
    }

    setupBehaviourTracking();
    logThisState("window.initInlineCP: finished");

}
function isValidEmail(email: string) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}
async function handleSubmit(form: HTMLFormElement, event?: JQueryEventObject): Promise<void> {
    if (event) {
        event.preventDefault();
    }
    const $checkoutForm = $('#checkout-form');
    const $submitButton = $checkoutForm.find(':input[type=submit]');
    const $errorHolder = $('.cb-main-footer .error-holder p.error');
    const $email = $('#email');
    const email = $email.val() as string;
    function enableSubmitButton() {
        $submitButton.prop('disabled', false);
    }
    function disableSubmitButton() {
        $submitButton.prop('disabled', true);
    }
    function displayError(message: string) {
        $errorHolder.text(message);
    }
    function handleError(error: string, gaEvent: string) {
        ga('send', 'event', 'Digital Checkout Page', gaEvent);
    }
    disableSubmitButton();
    displayError('');
    ga('send', 'event', 'Digital Checkout Page', 'UX - Submit Clicked');
    cpState.attemptCount++;
    let validEmail = isValidEmail(email);
    if (validEmail) {
        try {
            logThisState("initializeFormValidationAndSubmitHandler: start checkout if validated by Captcha");
            await grecaptcha.ready(async function () {
                try {
                    const token = await grecaptcha.execute('6LcmJLkZAAAAAMziOnaFrJkOV4ClF_H8OvcqvlyE', {action: 'submit'});
                    displayError('');
                    cpState.recaptchaToken = token;
                    logThisState("initializeFormValidationAndSubmitHandler: calling startCheckout");
                    if (cpState.paymentType === 'stripe-credit') {
                        logThisState("inlineCP:submitHandler: call callStripeCCSubmitHandler");
                        window._cpStripeDict.callStripeCCSubmitHandler();
                    } else if (cpState.paymentType === 'stripe-sepa-payment') {
                        logThisState("inlineCP:submitHandler: call callStripeSepaSubmitHandler");
                        window._cpStripeDict.callStripeSepaSubmitHandler();
                    } else if (cpState.paymentType === 'paypal') {
                        logThisState("inlineCP:submitHandler: call initializedPaypalHandler");
                        initPaypalExpressPayment();
                    } else {
                        logThisState("inlineCP:submitHandler: startCheckout");
                        await startCheckout();
                    }
                } catch (error) {
                    console.error('initializeFormValidationAndSubmitHandler: Error in grecaptcha.execute:', error);
                    enableSubmitButton();
                }
            });
        } catch (e) {
            handleError("initializeFormValidationAndSubmitHandler: exception-327", 'ERROR - startCheckout');
            handleError(`Digital Checkout Page - Error Log: ${e.message}`, 'checkoutpage:startCheckout');
            enableSubmitButton();
        }
    } else {
        $email.after(`<label id="email-error" class="error" for="email">Please enter a valid email address</label>`);
        $email.focus();
        enableSubmitButton();
    }
}
function initializeFormValidationAndSubmitHandler() {
    logThisState("window.initInlineCP: initializeFormValidationAndSubmitHandler: #checkout-form validate called");
    $('#checkout-form').validate({
        rules: {},
        messages: {},
        submitHandler: function (form, event) {

            handleSubmit(form, event).then(r => {
            });
        }
    });

}
function showPlanDescription() {
    let today = window.moment();
    const selectedPlan = cpState.selectedPlanDescription;
    const nextPlan = window.nextPlanDescription;
    const paymentDelay = cpState.selectedPlanDescription.planPeriod + ' ' +
        cpState.selectedPlanDescription.planPeriodUnit +
        (cpState.selectedPlanDescription.planPeriod > 1 ? 's' : '');
    const nextRenewal = today.add(selectedPlan.planPeriod, selectedPlan.planPeriodUnit);
    selectedPlan.planFrequencyString =
        (parseInt(nextPlan.planPeriod) > 1)
            ? (nextPlan.planPeriod + ' ' + nextPlan.planPeriodUnit + 's')
            : nextPlan.planPeriodUnit;
    $('.today-total-value').text(getMoneyString(cpState.offerDetail.content.first_billing_amount));

    $('.payment-delay-text').text(paymentDelay);

    if ((selectedPlan.giftValueSum - selectedPlan.giftValueGiftCard) === 0) {
        $(".gift-value-wrapper").hide();
    }
    $('.pre-loader').hide();
    $('.next .price-value').text('$' + getMoneyString(nextPlan.valueCharge));
    $('.next .date-value').text(nextRenewal.format('MMMM Do YYYY'));
    $('.next .frequency-value').text(selectedPlan.planFrequencyString);

}

function handleCustomFields() {
    let urlParams = window.epCheckoutParams;

    cpState.checkoutData.meta_data = {
        "cf_plan_after_trial_ends": window.epCheckoutParams.cf_plan_after_trial_ends,
        "cf_utm_campaign": urlParams.cf_utm_campaign || window.epCheckoutParams.utm_campaign,
        "cf_utm_source": urlParams.cf_utm_source || window.epCheckoutParams.utm_source,
        "cf_utm_medium": urlParams.cf_utm_medium || window.epCheckoutParams.utm_medium,
        "cf_utm_term": urlParams.cf_utm_term || window.epCheckoutParams.utm_term,
        "cf_utm_content": urlParams.cf_utm_content || window.epCheckoutParams.utm_content,
        "cf_source_page_variant": window.epCheckoutParams.cf_source_page_variant,
        "cf_source_page_url": (window.extractedURLParams.cf_source_page_url) ? window.extractedURLParams.cf_source_page_url.substr(0, 250) : "",
        "cf_impact_clickid": cpState.selectedPlanDescription.planId,

    }

    try {
        if (!cpState.checkoutData.meta_data.cf_utm_campaign && !cpState.checkoutData.meta_data.cf_utm_source && !cpState.checkoutData.meta_data.cf_utm_medium && !cpState.checkoutData.meta_data.cf_utm_term && !cpState.checkoutData.meta_data.cf_utm_content) {
            cpState.checkoutData.meta_data.cf_utm_campaign = window.epSubs.getVisitorUTMs().utm_campaign;
            cpState.checkoutData.meta_data.cf_utm_source = window.epSubs.getVisitorUTMs().utm_source;
            cpState.checkoutData.meta_data.cf_utm_medium = window.epSubs.getVisitorUTMs().utm_medium;
            cpState.checkoutData.meta_data.cf_utm_term = window.epSubs.getVisitorUTMs().utm_term;
            cpState.checkoutData.meta_data.cf_utm_content = window.epSubs.getVisitorUTMs().utm_content;
        }
    } catch (e) {
    }
    logThisState("handleCustomFields: cpState.checkoutData.meta_data=", cpState.checkoutData.meta_data);
}
/**
 * Get user information and check existing subscriptions and payment
 * @returns {Promise<void>}
 */
export async function setCustomerDetails() {

    try {
        let userInfo = await subscriptionAPIs.getUserInformation();
        logThisState("setCustomerDetails: Got user information", userInfo);
        cpState.customerData.email = userInfo.email;
        let $email = $('#email');
        $email.val(userInfo.email);
        $email.attr('disabled', 'true');


        if (userInfo.name) {
            let nameArr = userInfo.name.split(' ');
            $('#customer-fname').val(nameArr[0]);
            cpState.customerData.firstname = nameArr[0];
            if (nameArr.length > 1) {
                $('#customer-lname').val(nameArr[1]);
                cpState.customerData.lastname = nameArr[1];
            }
        }

        if (cpState.selectedPlanDescription.planId.indexOf('donation') === -1) {
            await checkExistingSubs(cpState.customerData.email, async (): Promise<void> => {
                await checkExistingPayment();
                logThisState("setCustomerDetails: after checkExistingPayment cpState.customerData.customer_id", cpState.customerData.customer_id);
            });
        }
    } catch (error) {
        logThisState("setCustomerDetails: generated error", error);
        ga('send', 'event', 'Digital Checkout Page', 'ERROR get user information', JSON.stringify(error));
    }
}

/**
 * Check if there is valid subscription
 * - if there is and it's digital, then show and exit
 * - if there is not then call the handler function which can be:
 *      -  await purchaseSubscription();
 *      or it is
 *      -  await checkExistingPayment();
 *
 * @param {string} email
 * @param {function} callback  is called if there is no valid subscription
 */
export async function checkExistingSubs(email: string, callback: () => Promise<void>) {
    try {

        logThisState("checkExistingSubs: for email", email);
        const resSubsInfo = await subscriptionAPIs.getExistingSubsInfo(email);
        logThisState("checkExistingSubs: got existingSubsInfo", resSubsInfo);
        let hasExistingSubscription = resSubsInfo && resSubsInfo.data && resSubsInfo.data.product_id;
        if (hasExistingSubscription) {
            cpState.customerData.customer_id = resSubsInfo.data.customer_id;
            logThisState("checkExistingSubs: found customer_id", cpState.customerData.customer_id);
        }
        if (cpState.customerData.forced_invalid_subscription) {
            hasExistingSubscription = false;
        }

        if (!hasExistingSubscription) {
            if (typeof callback == 'function') {
                logThisState("checkExistingSubs: has no valid Data Subscription, or simulated:", cpState.customerData.forced_invalid_subscription);
                callback();
            }
            return;
        }
        const subs_type = resSubsInfo.data.product_id;
        logThisState("checkExistingSubs: has existingSubInfo with subscription_type", subs_type);
        const subs_status = ('' + resSubsInfo.data.subscription_status).toLowerCase();

        if (digital_prod_id.includes(cpState.offerDetail.offer_detail.plan.product.id)) {
            if (subs_status === "active"
                && (digital_prod_id.includes(subs_type))) {
                logThisState("checkExistingSubs: has active existingSubInfo call handleExistingSubscription");
                handleExistingSubscription(subs_type);
                return;
            }


            if (typeof callback == 'function') {
                callback();
            }
        } else {
            if (typeof callback == 'function') {
                callback();
            }
        }
    } catch (e) {
        console.error("checkExistingSubs: e=", e);
        if (typeof callback == 'function') {
            callback();
        }
        ga('send', 'event', 'Digital Checkout Page', 'ERROR check existing subs info', JSON.stringify(e));
    }
}

export async function checkExistingPayment() {
    if (cpState.customerData.forced_invalid_payment) {
        logThisState("checkExistingPayment: forced to set payment to invalid");
        return;
    }
    if (!cpState.customerData.customer_id) {
        logThisState("checkExistingPayment: does not have an existing customer_id");
        return;
    }
    try {
        logThisState("checkExistingPayment: for cpState.customerData.customer_id", cpState.customerData.customer_id);
        let resPaymentMethod = await subscriptionAPIs.getPaymentMethod();
        logThisState("checkExistingPayment: got payment method", resPaymentMethod);
        if (resPaymentMethod && resPaymentMethod.data && !$.isEmptyObject(resPaymentMethod.data)) {
            logThisState("checkExistingPayment: payment method is set, calling handleExistingPayment " +
                "for resPaymentMethod.data.MaskedNumber", resPaymentMethod.data.MaskedNumber);
            handleExistingPayment(resPaymentMethod.data.MaskedNumber);
            cpState.hasExistingPayment = true;
            logThisState("checkExistingPayment: cpState.hasExistingPayment is set");
            cpState.customerData.customer_id = resPaymentMethod.data.CustomerID;
            logThisState("checkExistingPayment: set customer ID cpState.customerData.customer_id", cpState.customerData.customer_id);
        }
    } catch (error) {
        logThisState("checkExistingPayment: got error", error);
        ga('send', 'event', 'Digital Checkout Page', 'ERROR check existing payment information', JSON.stringify(error));
    }
}
function getStripeKey() {
    let stripeKey = 'pk_live_51HpXGBBkvvoYiDHGJ6bwN8ra8hRMN16nE8QY0I0dMIX7gbaPQd7SV4oTBUKFLAvmPFUgbDLjVjjA9he3Tsa4hGzK00G1nLIwsC';
    if (window.configUseTestStripe) {
        stripeKey = 'pk_test_51HpXGBBkvvoYiDHGVkmhqveXeGJtvNR0jAVAqDBK7oqTKybcPEFWL17TvMMgdrNOEUVHH7JkDNjQCNnam1zqWacm00O3SvLEmB';
    }
    return stripeKey;
}
async function initializeStripePaymentForSepa() {
    logThisState("initializeStripePaymentForSepa: called");
    cpState.paymentType = 'stripe-sepa-payment';
    let stripe: Stripe | null;
    try {
        stripe = await loadStripe(getStripeKey());
        logThisState("initializeStripePaymentForSepa: Stripe loaded successfully");
    } catch (e) {


        logError("Stripe load error, load braintree instead.", e);
        alert('STRIPE LOAD ERROR!');
        return;
    }

    const elements = stripe.elements();

    const iban = elements.create('iban', {
        style: {
            base: {
                fontSize: '16px',
            },
        },
        supportedCountries: ['SEPA'],
    });

    iban.mount('#iban-element');
    window._cpStripeDict.callStripeSepaSubmitHandler = () => {
        logThisState('callStripeSepaSubmitHandler is called');
        callSepaCreateForStripe(stripe, iban);
    }
    async function callSepaCreateForStripe(stripe: Stripe, iban: StripeIbanElement) {
        extractFormData('#checkout-form');
        logThisState("callSepaCreateForStripe: cpState.inputData", cpState.inputData);
        let $loading = $('.loading-throbber-wrapper');
        try {
            const stripeSepaPayload = {
                type: 'sepa_debit',
                currency: 'eur',

                owner: {
                    name: cpState.inputData.customer_fname + ' ' + cpState.inputData.customer_lname,
                    email: cpState.inputData.email,
                }
            };
            logThisState("callSepaCreateForStripe: stripeSepaPayload", JSON.stringify(stripeSepaPayload));
            const result = await stripe.createSource(iban, stripeSepaPayload);

            if (result.error) {
                throw new Error(result.error.message);
            }

            logThisState("initializeStripePaymentForSepa:stripe.createSource: " +
                "result: ", result);


            window._cpStripeDict.sepaResponsePayload = result;
            await startCheckout();
        } catch (e) {
            logThisState("initializeStripePaymentForSepa:stripe.createSource:error ", {err: e});
            $loading.fadeOut('fast');
            $('#purchase-btn').prop('disabled', false);
            outputLocalizedText('.error-holder .error', 'checkoutError');
        }
    }
}
async function initializeStripePaymentForCreditCard() {
    logThisState("initializeStripePaymentForCreditCard: called");
    cpState.paymentType = 'stripe-credit';
    let stripe: Stripe | null;
    try {
        stripe = await loadStripe(getStripeKey());
        logThisState("initializeStripePaymentForCreditCard: Stripe loaded successfully");
    } catch (e) {


        logError("Stripe load error, load braintree instead.", e);
        alert('STRIPE LOAD ERROR!');
        return;
    }
    const appearance: Appearance = {
        theme: 'none'
    };
    const elements = stripe.elements({appearance: appearance});
    const styles = {
        base: {
            fontSize: '16pt',
            color: '#3A3A3A',
            '::placeholder': {
                color: '#a9a9a9'
            },
            '::-webkit-input-placeholder': {
                color: '#a9a9a9'
            },
            ':-moz-placeholder': {
                color: '#a9a9a9'
            },
            '::-moz-placeholder': {
                color: '#a9a9a9'
            },
            ':-ms-input-placeholder ': {
                color: '#a9a9a9'
            },
        },
        invalid: {
            color: '#E25950',
        },
        valid: {
            color: 'green'
        }
    }
    const cardNumberElement = elements.create("cardNumber", {style: styles});
    const cardExpiryElement = elements.create("cardExpiry", {style: styles});
    const cardCvvElement = elements.create("cardCvc", {style: styles});
    cardNumberElement.mount("#stripe-card-number");
    cardExpiryElement.mount("#stripe-expiration-date");
    cardCvvElement.mount("#stripe-cvv");
    window._cpStripeDict.callStripeCCSubmitHandler = () => {
        logThisState('callStripeCCSubmitHandler is called with');
        stripeSubmitCreditCardHandler(stripe, cardNumberElement);
    }
    async function stripeSubmitCreditCardHandler(stripe: Stripe, cardNumberElement: StripeCardNumberElement) {
        let $loading = $('.loading-throbber-wrapper');
        try {
            $loading.fadeIn('fast');
            logThisState('cpState:', cpState);
            const billing_zip = $("#billing-zip").val();
            const res = await stripe.createPaymentMethod({
                type: 'card',
                card: cardNumberElement,
                billing_details: {
                    address: {
                        postal_code: (billing_zip as string)
                    }
                }
            });
            if (res && res.error) {
                throw new Error(res.error.message);
            }
            logThisState("window._cpStripeDict.responsePayload is set:", res.paymentMethod);
            window._cpStripeDict.responsePayload = res.paymentMethod;
            await startCheckout();
        } catch (e) {
            $loading.fadeOut('fast');
            $('#purchase-btn').prop('disabled', false);
            outputLocalizedText('.error-holder .error', 'checkoutError');
            logThisState("Stripe error response payload", {err: e});
        }
    }
}
//


